#!/usr/bin/env node

/**
 * KBO ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨ Ïä§ÌÅ¨Î¶ΩÌä∏
 * 2025-season-data-clean.txtÎ•º Í∏∞Î∞òÏúºÎ°ú Î™®Îì† ÏÑúÎπÑÏä§ ÏßÄÌëú Í≥ÑÏÇ∞
 */

const fs = require('fs');
const path = require('path');

class KBODataProcessor {
    constructor() {
        this.teams = ['ÌïúÌôî', 'LG', 'Î°ØÎç∞', 'SSG', 'KT', 'KIA', 'ÏÇºÏÑ±', 'NC', 'ÎëêÏÇ∞', 'ÌÇ§ÏõÄ'];
        this.allStarTeams = ['ÎÇòÎàî', 'ÎìúÎ¶º']; // Ïò¨Ïä§ÌÉÄ ÌåÄÎì§
        this.totalGamesPerSeason = 144;
        this.gamesPerOpponent = 16; // Í∞Å ÌåÄÎãπ 16Í≤ΩÍ∏∞Ïî©
        this.playoffSpots = 5;
        
        // KBO Ïã§Ï†ú ÏãúÏ¶å Í∏∞Ï§ÄÍ∞íÎì§
        this.typicalPlayoffWins = 80; // ÏùºÎ∞òÏ†ÅÏù∏ ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú ÏäπÏàò
        this.typicalChampionshipWins = 87; // 144Í≤ΩÍ∏∞ Ï≤¥Ï†ú 1ÏúÑÌåÄ ÌèâÍ∑† ÏäπÏàò (2015-2024ÎÖÑ: 86.9Ïäπ)
        
        // Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•ÏÜå
        this.games = [];
        this.teamStats = {};
        this.headToHead = {};
        this.standings = [];
        this.magicNumbers = {};
        this.remainingGames = {};
    }

    // 1. Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÌååÏã±
    parseGameData() {
        console.log('üìñ Í≤ΩÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÌååÏã± ÏãúÏûë...');
        
        try {
            // ÌòÑÏû¨ Ïó∞ÎèÑÏóê ÎßûÎäî ÌååÏùº Ï∞æÍ∏∞
            const currentYear = new Date().getFullYear();
            const possibleFiles = [
                `./data/${currentYear}-season-data-clean.txt`,
                './data/2025-season-data-clean.txt',
                './data/2024-season-data-clean.txt'
            ];
            
            let dataFile = null;
            for (const file of possibleFiles) {
                if (fs.existsSync(file)) {
                    dataFile = file;
                    break;
                }
            }
            
            if (!dataFile) {
                throw new Error('ÏãúÏ¶å Îç∞Ïù¥ÌÑ∞ ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
            }
            
            console.log(`üìÅ Îç∞Ïù¥ÌÑ∞ ÌååÏùº: ${dataFile}`);
            const data = fs.readFileSync(dataFile, 'utf8');
            const lines = data.trim().split('\n');
            
            let currentDate = '';
            let gameCount = 0;
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                
                // ÎÇ†Ïßú ÎùºÏù∏ Ï≤¥ÌÅ¨ (YYYY-MM-DD ÌòïÏãù)
                if (trimmedLine.match(/^\d{4}-\d{2}-\d{2}$/)) {
                    currentDate = trimmedLine;
                    continue;
                }
                
                // Í≤ΩÍ∏∞ Í≤∞Í≥º ÌååÏã± (ÌåÄ1 Ï†êÏàò:Ï†êÏàò ÌåÄ2(H) ÎòêÎäî ÌåÄ1 Ï†êÏàò:Ï†êÏàò ÌåÄ2)
                const gameMatch = trimmedLine.match(/^(.+?)\s+(\d+):(\d+)\s+(.+?)(\(H\))?$/);
                if (gameMatch) {
                    const [, team1, score1, score2, team2Raw, homeMarker] = gameMatch;
                    
                    // Ïò¨Ïä§ÌÉÄ Í≤ΩÍ∏∞ Ï†úÏô∏
                    if (this.allStarTeams.includes(team1.trim()) || this.allStarTeams.includes(team2Raw.trim())) {
                        console.log(`  ‚≠ê Ïò¨Ïä§ÌÉÄ Í≤ΩÍ∏∞ Ï†úÏô∏: ${team1} vs ${team2Raw}`);
                        continue;
                    }
                    
                    // ÌôàÌåÄ ÏãùÎ≥Ñ: (H) ÌëúÏãúÍ∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ ÌåÄÏù¥ ÌôàÌåÄ, ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Í∑úÏπô Ï†ÅÏö©
                    let homeTeam, awayTeam, team2;
                    if (homeMarker === '(H)') {
                        // (H) ÌëúÏãúÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ - Î™ÖÏãúÏ†Å ÌôàÌåÄ ÌëúÏãú
                        team2 = team2Raw;
                        homeTeam = team2;
                        awayTeam = team1;
                    } else {
                        // (H) ÌëúÏãúÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ - Í∏∞Ï°¥ Í∑úÏπô (Îí§Ïóê ÎÇòÏò® ÌåÄÏù¥ ÌôàÌåÄ)
                        team2 = team2Raw;
                        homeTeam = team2;
                        awayTeam = team1;
                    }
                    
                    // Í≤∞Í≥º ÌåêÏ†ï
                    let result;
                    if (parseInt(score1) > parseInt(score2)) {
                        result = { winner: team1, loser: team2, isDraw: false };
                    } else if (parseInt(score1) < parseInt(score2)) {
                        result = { winner: team2, loser: team1, isDraw: false };
                    } else {
                        result = { winner: null, loser: null, isDraw: true };
                    }
                    
                    this.games.push({
                        date: currentDate,
                        team1: team1,
                        team2: team2,
                        score1: parseInt(score1),
                        score2: parseInt(score2),
                        homeTeam: homeTeam,
                        awayTeam: awayTeam,
                        homeMarkerPresent: !!homeMarker, // Î†àÌçºÎü∞Ïä§Ïö©
                        ...result
                    });
                    
                    gameCount++;
                }
            }
            
            console.log(`‚úÖ ÌååÏã± ÏôÑÎ£å: ${gameCount}Í≤ΩÍ∏∞, ÏµúÏã† ÎÇ†Ïßú: ${currentDate}`);
            return { gameCount, lastDate: currentDate };
            
        } catch (error) {
            console.error('‚ùå ÌååÏã± Ïã§Ìå®:', error.message);
            throw error;
        }
    }

    // 2. ÌåÄÎ≥Ñ Í∏∞Î≥∏ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
    calculateTeamStats() {
        console.log('üìä ÌåÄÎ≥Ñ ÌÜµÍ≥Ñ Í≥ÑÏÇ∞ Ï§ë...');
        console.log(`  üéÆ Ï≤òÎ¶¨Ìï† Í≤ΩÍ∏∞ Ïàò: ${this.games.length}`);
        
        // Ï¥àÍ∏∞Ìôî
        this.teams.forEach(team => {
            this.teamStats[team] = {
                games: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                homeWins: 0,
                homeLosses: 0,
                homeDraws: 0,
                awayWins: 0,
                awayLosses: 0,
                awayDraws: 0,
                recent10: [],
                currentStreak: { type: '', count: 0 }
            };
        });
        
        // Í≤ΩÍ∏∞Î≥Ñ ÌÜµÍ≥Ñ ÎàÑÏ†Å
        for (const game of this.games) {
            const { team1, team2, homeTeam, awayTeam, winner, loser, isDraw } = game;
            
            // ÌåÄ Ïù¥Î¶Ñ ÌôïÏù∏ (ÎîîÎ≤ÑÍπÖ)
            if (!this.teamStats[team1]) {
                console.error(`  ‚ùå Ïïå Ïàò ÏóÜÎäî ÌåÄ: '${team1}'`);
                console.error(`     Í≤ΩÍ∏∞ Ï†ïÎ≥¥:`, JSON.stringify(game));
                continue;
            }
            if (!this.teamStats[team2]) {
                console.error(`  ‚ùå Ïïå Ïàò ÏóÜÎäî ÌåÄ: '${team2}'`);
                console.error(`     Í≤ΩÍ∏∞ Ï†ïÎ≥¥:`, JSON.stringify(game));
                continue;
            }
            
            // Îëê ÌåÄ Î™®Îëê Í≤ΩÍ∏∞Ïàò Ï¶ùÍ∞Ä
            this.teamStats[team1].games++;
            this.teamStats[team2].games++;
            
            if (isDraw) {
                // Î¨¥ÏäπÎ∂Ä
                this.teamStats[team1].draws++;
                this.teamStats[team2].draws++;
                
                // Ìôà/ÏõêÏ†ï Î¨¥ÏäπÎ∂Ä
                this.teamStats[homeTeam].homeDraws++;
                this.teamStats[awayTeam].awayDraws++;
                
                // ÏµúÍ∑º 10Í≤ΩÍ∏∞ Í∏∞Î°ù
                this.teamStats[team1].recent10.push('Î¨¥');
                this.teamStats[team2].recent10.push('Î¨¥');
                
            } else {
                // ÏäπÎ∂Ä Í≤∞Ï†ï
                this.teamStats[winner].wins++;
                this.teamStats[loser].losses++;
                
                // Ìôà/ÏõêÏ†ï ÏäπÌå®
                if (winner === homeTeam) {
                    this.teamStats[winner].homeWins++;
                    this.teamStats[loser].awayLosses++;
                } else {
                    this.teamStats[winner].awayWins++;
                    this.teamStats[loser].homeLosses++;
                }
                
                // ÏµúÍ∑º 10Í≤ΩÍ∏∞ Í∏∞Î°ù
                this.teamStats[winner].recent10.push('Ïäπ');
                this.teamStats[loser].recent10.push('Ìå®');
            }
        }
        
        // ÌõÑÏ≤òÎ¶¨: ÏäπÎ•†, ÏµúÍ∑º 10Í≤ΩÍ∏∞, Ïó∞ÏÜç Í∏∞Î°ù Í≥ÑÏÇ∞
        this.teams.forEach(team => {
            const stats = this.teamStats[team];
            
            // ÏäπÎ•† Í≥ÑÏÇ∞
            stats.winRate = stats.wins / (stats.wins + stats.losses) || 0;
            
            // ÏµúÍ∑º 10Í≤ΩÍ∏∞ Ï†ïÎ¶¨ (ÏµúÏã† 10Í∞úÎßå)
            stats.recent10 = stats.recent10.slice(-10);
            const recent10Summary = this.formatRecent10(stats.recent10);
            stats.recent10Display = recent10Summary;
            
            // ÌòÑÏû¨ Ïó∞ÏÜç Í∏∞Î°ù Í≥ÑÏÇ∞
            stats.currentStreak = this.calculateStreak(stats.recent10);
            
            // Ìôà/ÏõêÏ†ï Í∏∞Î°ù Î¨∏ÏûêÏó¥
            stats.homeRecord = `${stats.homeWins}-${stats.homeLosses}-${stats.homeDraws}`;
            stats.awayRecord = `${stats.awayWins}-${stats.awayLosses}-${stats.awayDraws}`;
            
            console.log(`  üìà ${team}: ${stats.games}Í≤ΩÍ∏∞ ${stats.wins}Ïäπ${stats.losses}Ìå®${stats.draws}Î¨¥ (.${(stats.winRate * 1000).toFixed(0)})`);
        });
    }

    // 3. ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞
    calculateHeadToHead() {
        console.log('‚öîÔ∏è ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞ Ï§ë...');
        
        // Ï¥àÍ∏∞Ìôî
        this.teams.forEach(team1 => {
            this.headToHead[team1] = {};
            this.teams.forEach(team2 => {
                if (team1 !== team2) {
                    this.headToHead[team1][team2] = { 
                        wins: 0, losses: 0, draws: 0,
                        homeWins: 0, homeLosses: 0, homeDraws: 0,
                        awayWins: 0, awayLosses: 0, awayDraws: 0
                    };
                }
            });
        });
        
        // Í≤ΩÍ∏∞Î≥Ñ ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞
        for (const game of this.games) {
            const { team1, team2, homeTeam, awayTeam, winner, loser, isDraw } = game;
            
            if (isDraw) {
                // Ï†ÑÏ≤¥ Î¨¥ÏäπÎ∂Ä
                this.headToHead[team1][team2].draws++;
                this.headToHead[team2][team1].draws++;
                
                // Ìôà/ÏõêÏ†ï Î¨¥ÏäπÎ∂Ä
                this.headToHead[homeTeam][awayTeam].homeDraws++;
                this.headToHead[awayTeam][homeTeam].awayDraws++;
            } else {
                // Ï†ÑÏ≤¥ ÏäπÌå®
                this.headToHead[winner][loser].wins++;
                this.headToHead[loser][winner].losses++;
                
                // Ìôà/ÏõêÏ†ï ÏäπÌå®
                if (winner === homeTeam) {
                    // ÌôàÌåÄ ÏäπÎ¶¨
                    this.headToHead[homeTeam][awayTeam].homeWins++;
                    this.headToHead[awayTeam][homeTeam].awayLosses++;
                } else {
                    // ÏõêÏ†ïÌåÄ ÏäπÎ¶¨
                    this.headToHead[awayTeam][homeTeam].awayWins++;
                    this.headToHead[homeTeam][awayTeam].homeLosses++;
                }
            }
        }
        
        // ÏÉÅÎåÄÏ†ÑÏ†Å ÏöîÏïΩ Ï∂úÎ†•
        console.log('  ‚öîÔ∏è ÏÉÅÎåÄÏ†ÑÏ†Å Îß§Ìä∏Î¶≠Ïä§ ÏôÑÏÑ±');
        this.teams.forEach(team => {
            const totalGames = Object.values(this.headToHead[team])
                .reduce((sum, record) => sum + record.wins + record.losses + record.draws, 0);
            console.log(`    ${team}: Ï¥ù ${totalGames}Í≤ΩÍ∏∞`);
        });
    }

    // 4. ÏûîÏó¨Í≤ΩÍ∏∞ Í≥ÑÏÇ∞
    calculateRemainingGames() {
        console.log('üìÖ ÏûîÏó¨Í≤ΩÍ∏∞ Í≥ÑÏÇ∞ Ï§ë...');
        
        this.teams.forEach(team1 => {
            this.remainingGames[team1] = {};
            let totalRemaining = 0;
            
            this.teams.forEach(team2 => {
                if (team1 !== team2) {
                    const played = this.headToHead[team1][team2].wins + 
                                  this.headToHead[team1][team2].losses + 
                                  this.headToHead[team1][team2].draws;
                    
                    const remaining = this.gamesPerOpponent - played;
                    this.remainingGames[team1][team2] = Math.max(0, remaining);
                    totalRemaining += this.remainingGames[team1][team2];
                }
            });
            
            this.remainingGames[team1].total = totalRemaining;
            console.log(`  üìÖ ${team1}: ${totalRemaining}Í≤ΩÍ∏∞ ÎÇ®Ïùå`);
        });
    }

    // 5. ÏàúÏúÑ Í≥ÑÏÇ∞
    calculateStandings() {
        console.log('üèÜ ÏàúÏúÑ Í≥ÑÏÇ∞ Ï§ë...');
        
        this.standings = this.teams.map(team => {
            const stats = this.teamStats[team];
            return {
                team: team,
                games: stats.games,
                wins: stats.wins,
                losses: stats.losses,
                draws: stats.draws,
                winRate: stats.winRate,
                homeRecord: stats.homeRecord,
                awayRecord: stats.awayRecord,
                homeWins: stats.homeWins,
                homeLosses: stats.homeLosses,
                homeDraws: stats.homeDraws,
                awayWins: stats.awayWins,
                awayLosses: stats.awayLosses,
                awayDraws: stats.awayDraws,
                recent10: stats.recent10Display,
                streak: this.formatStreak(stats.currentStreak),
                remainingGames: this.remainingGames[team].total
            };
        });
        
        // ÏàúÏúÑ Ï†ïÎ†¨ (ÏäπÎ•† Í∏∞Ï§Ä)
        this.standings.sort((a, b) => {
            if (b.winRate !== a.winRate) return b.winRate - a.winRate;
            if (b.wins !== a.wins) return b.wins - a.wins;
            return a.losses - b.losses;
        });
        
        // ÏàúÏúÑ Î∞è Í≤åÏûÑÏ∞® Í≥ÑÏÇ∞
        this.standings.forEach((team, index) => {
            team.rank = index + 1;
            
            if (index === 0) {
                team.gamesBehind = 0;
            } else {
                const firstPlace = this.standings[0];
                team.gamesBehind = (firstPlace.wins - team.wins + team.losses - firstPlace.losses) / 2;
            }
        });
        
        console.log('  üèÜ ÏàúÏúÑÌëú ÏôÑÏÑ±:');
        this.standings.forEach(team => {
            console.log(`    ${team.rank}ÏúÑ ${team.team} (${team.wins}-${team.losses}-${team.draws}, .${(team.winRate * 1000).toFixed(0)})`);
        });
    }

    // 6. Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞
    calculateMagicNumbers() {
        console.log('üîÆ Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞ Ï§ë...');
        
        this.magicNumbers = {};
        
        this.standings.forEach((team, index) => {
            const remainingGames = team.remainingGames;
            const maxPossibleWins = team.wins + remainingGames;
            
            // ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú Îß§ÏßÅÎÑòÎ≤Ñ
            let playoffMagic = this.calculatePlayoffMagic(team, index);
            
            // Ïö∞Ïäπ Îß§ÏßÅÎÑòÎ≤Ñ  
            let championshipMagic = this.calculateChampionshipMagic(team, index);
            
            // ÌÉàÎùΩ Îß§ÏßÅÎÑòÎ≤Ñ
            let eliminationMagic = this.calculateEliminationMagic(team, index);
            
            // Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ Îß§ÏßÅÎÑòÎ≤Ñ (2ÏúÑ ÌôïÏ†ï)
            let homeAdvantage = this.calculateHomeAdvantageMagic(team, index);
            
            this.magicNumbers[team.team] = {
                playoff: playoffMagic,
                championship: championshipMagic,
                elimination: eliminationMagic,
                homeAdvantage: homeAdvantage,
                remainingGames: remainingGames,
                maxPossibleWins: maxPossibleWins,
                currentRank: team.rank
            };
            
            console.log(`  üéØ ${team.team} (${team.rank}ÏúÑ): PO ${playoffMagic}, Ïö∞Ïäπ ${championshipMagic}`);
        });
    }

    // Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞ Ìó¨Ìçº Ìï®ÏàòÎì§
    calculatePlayoffMagic(team, index) {
        if (index < this.playoffSpots) {
            // ÌòÑÏû¨ ÌîåÎ†àÏù¥Ïò§ÌîÑ Í∂å ÎÇ¥ - ÌîåÎ†àÏù¥Ïò§ÌîÑ ÌôïÏ†ïÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const sixthPlace = this.standings[this.playoffSpots];
            if (!sixthPlace) return 0; // 6ÏúÑ ÌåÄÏù¥ ÏóÜÏúºÎ©¥ Ïù¥ÎØ∏ ÌôïÏ†ï
            
            // 6ÏúÑ ÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÏàòÎ≥¥Îã§ 1Ïäπ Îçî ÌïÑÏöî
            const sixthMaxWins = sixthPlace.wins + sixthPlace.remainingGames;
            const neededWins = Math.max(0, sixthMaxWins - team.wins + 1);
            
            // ÎÇ®ÏùÄ Í≤ΩÍ∏∞Î°ú Îã¨ÏÑ± Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
            return neededWins > team.remainingGames ? 999 : neededWins;
        } else {
            // ÌîåÎ†àÏù¥Ïò§ÌîÑ Í∂å Î∞ñ - ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂úÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            // 5ÏúÑ ÌåÄÏùò ÌòÑÏû¨ ÏäπÏàòÎ•º ÎÑòÏñ¥ÏÑúÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏäπÏàò
            const fifthPlace = this.standings[this.playoffSpots - 1];
            const maxPossibleWins = team.wins + team.remainingGames;
            
            // ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞ Ï≤¥ÌÅ¨
            if (maxPossibleWins < fifthPlace.wins) {
                return 999; // Ïù¥ÎØ∏ ÏàòÌïôÏ†Å ÌÉàÎùΩ
            }
            
            // 5ÏúÑÎ•º Ï∂îÏõîÌïòÍ∏∞ ÏúÑÌïú ÏµúÏÜå ÏäπÏàò Í≥ÑÏÇ∞
            const neededWins = Math.max(0, fifthPlace.wins - team.wins + 1);
            return neededWins > team.remainingGames ? 999 : neededWins;
        }
    }

    calculateChampionshipMagic(team, index) {
        if (index === 0) {
            // ÌòÑÏû¨ 1ÏúÑ - Ïö∞Ïäπ ÌôïÏ†ïÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const secondPlace = this.standings[1];
            if (!secondPlace) return 0; // 2ÏúÑÍ∞Ä ÏóÜÏúºÎ©¥ Ïù¥ÎØ∏ ÌôïÏ†ï
            
            // 2ÏúÑ ÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÏàòÎ≥¥Îã§ 1Ïäπ Îçî ÌïÑÏöî
            const secondMaxWins = secondPlace.wins + secondPlace.remainingGames;
            const neededWins = Math.max(0, secondMaxWins - team.wins + 1);
            
            // ÎÇ®ÏùÄ Í≤ΩÍ∏∞Î°ú Îã¨ÏÑ± Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
            return neededWins > team.remainingGames ? 999 : neededWins;
        } else {
            // 1ÏúÑÍ∞Ä ÏïÑÎãò - 1ÏúÑ Ï∂îÏõîÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const firstPlace = this.standings[0];
            const maxPossibleWins = team.wins + team.remainingGames;
            
            // ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞
            if (maxPossibleWins < firstPlace.wins) {
                return 999; // Ïù¥ÎØ∏ ÏàòÌïôÏ†Å Î∂àÍ∞ÄÎä•
            }
            
            // 1ÏúÑ ÌåÄÏùÑ ÎÑòÏñ¥ÏÑúÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏäπÏàò
            const neededWins = Math.max(0, firstPlace.wins - team.wins + 1);
            return neededWins > team.remainingGames ? 999 : neededWins;
        }
    }

    calculateEliminationMagic(team, index) {
        // ÌÉàÎùΩ Îß§ÏßÅÎÑòÎ≤Ñ: ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂úÏù¥ ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•Ìï¥ÏßÄÎäî Ìå®Î∞∞ Ïàò
        if (index < this.playoffSpots) {
            // ÌòÑÏû¨ ÌîåÎ†àÏù¥Ïò§ÌîÑ Í∂å ÎÇ¥ - ÌÉàÎùΩÍπåÏßÄ Î™á Ìå® ÎÇ®ÏïòÎäîÍ∞Ä
            const sixthPlace = this.standings[this.playoffSpots];
            if (!sixthPlace) return 999; // 6ÏúÑÍ∞Ä ÏóÜÏúºÎ©¥ ÌÉàÎùΩ Î∂àÍ∞ÄÎä•
            
            // 6ÏúÑ ÌåÄÏù¥ Î™®Îì† Í≤ΩÍ∏∞Î•º Ïù¥Í≤®ÎèÑ Îî∞ÎùºÏû°ÏùÑ Ïàò ÏóÜÏùÑ ÎïåÍπåÏßÄÏùò Ìå®Î∞∞ Ïàò
            const sixthMaxWins = sixthPlace.wins + sixthPlace.remainingGames;
            const currentMaxWins = team.wins + team.remainingGames;
            
            if (currentMaxWins > sixthMaxWins) {
                return 999; // Ïù¥ÎØ∏ ÌîåÎ†àÏù¥Ïò§ÌîÑ ÌôïÏ†ï
            }
            
            // Î™á Î≤à Îçî ÏßÄÎ©¥ 6ÏúÑÏóêÍ≤å Ï∂îÏõîÎãπÌïòÎäîÍ∞Ä
            const lossesToElimination = Math.max(0, team.remainingGames - (sixthMaxWins - team.wins) + 1);
            return lossesToElimination;
        } else {
            // ÌîåÎ†àÏù¥Ïò§ÌîÑ Í∂å Î∞ñ - Ïù¥ÎØ∏ ÌÉàÎùΩÌñàÍ±∞ÎÇò ÏßÑÏ∂ú Í∞ÄÎä•ÏÑ± ÌôïÏù∏
            const fifthPlace = this.standings[this.playoffSpots - 1];
            const maxPossibleWins = team.wins + team.remainingGames;
            
            if (maxPossibleWins <= fifthPlace.wins) {
                return 0; // Ïù¥ÎØ∏ ÏàòÌïôÏ†ÅÏúºÎ°ú ÌÉàÎùΩ
            }
            
            return 999; // ÏïÑÏßÅ ÏßÑÏ∂ú Í∞ÄÎä•ÏÑ± ÏûàÏùå
        }
    }

    calculateHomeAdvantageMagic(team, index) {
        // Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ Îß§ÏßÅÎÑòÎ≤Ñ: 2ÏúÑ Ïù¥ÎÇ¥ ÌôïÏ†ïÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
        if (index <= 1) {
            // ÌòÑÏû¨ 1-2ÏúÑ - Ìôà Ïñ¥ÎìúÎ∞¥Ìã∞ÏßÄ ÌôïÏ†ïÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const thirdPlace = this.standings[2];
            if (!thirdPlace) return 0; // 3ÏúÑÍ∞Ä ÏóÜÏúºÎ©¥ Ïù¥ÎØ∏ ÌôïÏ†ï
            
            // 3ÏúÑ ÌåÄÏùò ÏµúÎåÄ Í∞ÄÎä• ÏäπÏàòÎ≥¥Îã§ 1Ïäπ Îçî ÌïÑÏöî
            const thirdMaxWins = thirdPlace.wins + thirdPlace.remainingGames;
            const neededWins = Math.max(0, thirdMaxWins - team.wins + 1);
            
            // ÎÇ®ÏùÄ Í≤ΩÍ∏∞Î°ú Îã¨ÏÑ± Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
            return neededWins > team.remainingGames ? 999 : neededWins;
        } else {
            // 3ÏúÑ Ïù¥Ìïò - 2ÏúÑ ÏßÑÏûÖÏùÑ ÏúÑÌïú Îß§ÏßÅÎÑòÎ≤Ñ
            const secondPlace = this.standings[1];
            const maxPossibleWins = team.wins + team.remainingGames;
            
            // ÏàòÌïôÏ†ÅÏúºÎ°ú Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞
            if (maxPossibleWins < secondPlace.wins) {
                return 999; // Ïù¥ÎØ∏ ÏàòÌïôÏ†Å Î∂àÍ∞ÄÎä•
            }
            
            // 2ÏúÑ ÌåÄÏùÑ ÎÑòÏñ¥ÏÑúÍ∏∞ ÏúÑÌï¥ ÌïÑÏöîÌïú ÏäπÏàò
            const neededWins = Math.max(0, secondPlace.wins - team.wins + 1);
            return neededWins > team.remainingGames ? 999 : neededWins;
        }
    }

    // 7. ÌÜµÌï© ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    generateServiceData() {
        console.log('üì¶ ÌÜµÌï© ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Ï§ë...');
        
        const serviceData = {
            lastUpdated: new Date().toISOString(),
            updateDate: new Date().toLocaleDateString('ko-KR'),
            note: '2025-season-data-clean.txt Í∏∞Î∞ò ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨',
            source: 'CLEAN_TXT_AUTOMATION',
            dataDate: this.games.length > 0 ? this.games[this.games.length - 1].date : null,
            totalGames: this.games.length,
            
            // ÏàúÏúÑÌëú
            standings: this.standings,
            
            // Îß§ÏßÅÎÑòÎ≤Ñ
            magicNumbers: this.magicNumbers,
            
            // ÏÉÅÎåÄÏ†ÑÏ†Å
            headToHead: this.headToHead,
            
            // ÏûîÏó¨Í≤ΩÍ∏∞
            remainingGames: this.remainingGames,
            
            // 1ÏúÑ ÌÉàÌôò Í∞ÄÎä•ÏÑ± Îç∞Ïù¥ÌÑ∞
            chaseData: this.generateChaseData(),
            
            // ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú Îç∞Ïù¥ÌÑ∞
            playoffData: this.generatePlayoffData()
        };
        
        return serviceData;
    }

    // 1ÏúÑ ÌÉàÌôò Í∞ÄÎä•ÏÑ± Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    generateChaseData() {
        const firstPlace = this.standings[0];
        
        return this.standings.slice(1).map(team => {
            const maxPossibleWins = team.wins + team.remainingGames;
            const canChase = maxPossibleWins > firstPlace.wins;
            const firstTeamNeedToLose = Math.max(0, maxPossibleWins - firstPlace.wins);
            const requiredWinRate = team.remainingGames > 0 ? 
                Math.min(1, (this.typicalChampionshipWins - team.wins) / team.remainingGames) : 0;
            
            return {
                team: team.team,
                rank: team.rank,
                wins: team.wins,
                gamesBehind: team.gamesBehind,
                remainingGames: team.remainingGames,
                maxPossibleWins: maxPossibleWins,
                firstTeamNeedToLose: firstTeamNeedToLose,
                canChase: canChase,
                requiredWinRate: requiredWinRate,
                canReachChampionshipWins: maxPossibleWins >= this.typicalChampionshipWins
            };
        });
    }

    // ÌîåÎ†àÏù¥Ïò§ÌîÑ ÏßÑÏ∂ú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    generatePlayoffData() {
        return this.standings.map(team => {
            const magic = this.magicNumbers[team.team];
            const requiredWinRate = team.remainingGames > 0 ? 
                Math.min(1, magic.playoff / team.remainingGames) : 0;
            
            let status = 'Î∂àÍ∞ÄÎä•';
            if (magic.playoff <= 0) status = 'ÌôïÏ†ï';
            else if (magic.playoff <= 10) status = 'ÏßÑÏ∂ú Ïú†Î†•';
            else if (magic.playoff <= 20) status = 'Í≤ΩÌï©';
            else if (magic.playoff < 999) status = 'Ïñ¥Î†§ÏõÄ';
            
            return {
                team: team.team,
                rank: team.rank,
                wins: team.wins,
                remainingGames: team.remainingGames,
                maxPossibleWins: magic.maxPossibleWins,
                playoffMagic: magic.playoff === 999 ? '-' : magic.playoff,
                requiredWinRate: requiredWinRate,
                status: status
            };
        });
    }

    // 8. ÌååÏùº Ï†ÄÏû•
    async saveAllData(serviceData) {
        console.log('üíæ Îç∞Ïù¥ÌÑ∞ ÌååÏùº Ï†ÄÏû• Ï§ë...');
        
        try {
            // 1. ÌÜµÌï© ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞
            fs.writeFileSync('./output/service-data.json', JSON.stringify(serviceData, null, 2));
            console.log('  ‚úÖ output/service-data.json Ï†ÄÏû• ÏôÑÎ£å');
            
            // 2. magic-number Ìè¥ÎçîÏóê ÏõπÏÑúÎπÑÏä§Ïö© ÌååÏùºÎì§ ÏÉùÏÑ±
            const rankingsData = {
                lastUpdated: serviceData.lastUpdated,
                updateDate: serviceData.updateDate,
                note: serviceData.note,
                rankings: serviceData.standings.map(team => ({
                    rank: team.rank,
                    team: team.team,
                    games: team.games,
                    wins: team.wins,
                    losses: team.losses,
                    draws: team.draws,
                    winRate: parseFloat(team.winRate.toFixed(3)),
                    gamesBehind: team.gamesBehind,
                    recent10: team.recent10,
                    streak: team.streak,
                    homeRecord: team.homeRecord,
                    awayRecord: team.awayRecord
                })),
                magicNumbers: serviceData.magicNumbers,
                lastMagicUpdate: serviceData.lastUpdated,
                totalTeams: 10,
                source: serviceData.source,
                dataDate: serviceData.dataDate
            };
            
            // 3. magic-number Ìè¥ÎçîÏóê ÏõπÏÑúÎπÑÏä§ ÌååÏùºÎì§ ÏÉùÏÑ±
            if (fs.existsSync('./magic-number')) {
                fs.writeFileSync('./magic-number/kbo-rankings.json', JSON.stringify(rankingsData, null, 2));
                
                // ÏÉÅÎåÄÏ†ÑÏ†Å Îç∞Ïù¥ÌÑ∞ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
                const recordsData = {
                    lastUpdated: serviceData.lastUpdated,
                    updateDate: serviceData.updateDate,
                    note: serviceData.note,
                    totalData: serviceData.headToHead,
                    source: serviceData.source,
                    dataDate: serviceData.dataDate
                };
                
                fs.writeFileSync('./magic-number/kbo-records.json', JSON.stringify(recordsData, null, 2));
                console.log('  ‚úÖ magic-number Ìè¥Îçî ÌååÏùºÎì§ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å');
            }
            
        } catch (error) {
            console.error('‚ùå ÌååÏùº Ï†ÄÏû• Ïã§Ìå®:', error.message);
            throw error;
        }
    }

    // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
    formatRecent10(games) {
        const wins = games.filter(g => g === 'Ïäπ').length;
        const losses = games.filter(g => g === 'Ìå®').length;
        const draws = games.filter(g => g === 'Î¨¥').length;
        
        return `${wins}Ïäπ${draws}Î¨¥${losses}Ìå®`;
    }

    calculateStreak(recent) {
        if (recent.length === 0) return { type: '', count: 0 };
        
        // Í∞ÄÏû• ÏµúÍ∑ºÎ∂ÄÌÑ∞ Í±∞Íæ∏Î°ú ÏàúÌöåÌïòÎ©∞ Ïäπ ÎòêÎäî Ìå® Ïó∞ÏÜç Ï∞æÍ∏∞
        let streakType = '';
        let count = 0;
        
        for (let i = recent.length - 1; i >= 0; i--) {
            const result = recent[i];
            
            // Î¨¥ÏäπÎ∂ÄÎäî Ïó∞ÏÜçÏóê ÏòÅÌñ•ÏùÑ Ï£ºÏßÄ ÏïäÏùå (Í±¥ÎìúÎ¶¨ÏßÄ ÏïäÍ≥† Ìå®Ïä§)
            if (result === 'Î¨¥') {
                continue;
            }
            
            // Ï≤´ Î≤àÏß∏ Ïäπ/Ìå® Í≤∞Í≥ºÎ•º Ï∞æÏùÄ Í≤ΩÏö∞
            if (streakType === '') {
                streakType = result;
                count = 1;
            }
            // Í∞ôÏùÄ Í≤∞Í≥ºÍ∞Ä Ïó∞ÏÜçÎêòÎäî Í≤ΩÏö∞
            else if (result === streakType) {
                count++;
            }
            // Îã§Î•∏ Í≤∞Í≥ºÍ∞Ä ÎÇòÏò§Î©¥ Ïó∞ÏÜç Ï§ëÎã®
            else {
                break;
            }
        }
        
        return { type: streakType, count: count };
    }

    formatStreak(streak) {
        if (streak.count === 0) return '-';
        return `${streak.count}${streak.type}`;
    }

    // Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
    async run() {
        try {
            console.log('üöÄ KBO Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨ ÏãúÏûë...\n');
            
            // 1Îã®Í≥Ñ: Îç∞Ïù¥ÌÑ∞ ÌååÏã±
            const parseResult = this.parseGameData();
            
            // 2Îã®Í≥Ñ: ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
            this.calculateTeamStats();
            
            // 3Îã®Í≥Ñ: ÏÉÅÎåÄÏ†ÑÏ†Å Í≥ÑÏÇ∞
            this.calculateHeadToHead();
            
            // 4Îã®Í≥Ñ: ÏûîÏó¨Í≤ΩÍ∏∞ Í≥ÑÏÇ∞
            this.calculateRemainingGames();
            
            // 5Îã®Í≥Ñ: ÏàúÏúÑ Í≥ÑÏÇ∞
            this.calculateStandings();
            
            // 6Îã®Í≥Ñ: Îß§ÏßÅÎÑòÎ≤Ñ Í≥ÑÏÇ∞
            this.calculateMagicNumbers();
            
            // 7Îã®Í≥Ñ: ÏÑúÎπÑÏä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            const serviceData = this.generateServiceData();
            
            // 8Îã®Í≥Ñ: ÌååÏùº Ï†ÄÏû•
            await this.saveAllData(serviceData);
            
            console.log('\nüéâ KBO Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÏûêÎèôÌôî Ï≤òÎ¶¨ ÏôÑÎ£å!');
            console.log(`üìä Ï¥ù ${parseResult.gameCount}Í≤ΩÍ∏∞ Ï≤òÎ¶¨`);
            console.log(`üìÖ ÏµúÏã† Îç∞Ïù¥ÌÑ∞: ${parseResult.lastDate}`);
            console.log('üìÅ ÏÉùÏÑ±Îêú ÌååÏùº:');
            console.log('   - output/service-data.json (ÌÜµÌï© Îç∞Ïù¥ÌÑ∞)');
            console.log('   - magic-number/kbo-rankings.json (ÏõπÏÑúÎπÑÏä§Ïö© ÏàúÏúÑ)');
            console.log('   - magic-number/kbo-records.json (ÏõπÏÑúÎπÑÏä§Ïö© ÏÉÅÎåÄÏ†ÑÏ†Å)');
            
        } catch (error) {
            console.error('\n‚ùå Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù:', error.message);
            process.exit(1);
        }
    }
}

// Ïã§Ìñâ
if (require.main === module) {
    const processor = new KBODataProcessor();
    processor.run();
}

module.exports = KBODataProcessor;